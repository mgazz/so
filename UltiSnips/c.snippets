snippet cnew "pthread condition" b
pthread_cond_t ${1:name};
pthread_cond_init(&m.$1,NULL);
printf("\t\tm.coda_$1:%d\n",m.coda_$1);
endsnippet

snippet cnew1 "pthread condition[]" b
pthread_cond_t ${1:name}[${2:N}];
int coda_$1[$2];

//init
for (int i = 0; i < $2; ++i)
{
	pthread_cond_init(&m.$1[i],NULL);
	m.coda_$1[i]=0;
}

//print_stat()
for (int i = 0; i < $2; ++i)
{
	printf("\t\tm.coda_$1[%d]: %d\n",i,m.coda_$1[i]);
}
endsnippet

snippet cnew2 "pthread condition[][]" b
pthread_cond_t ${1:name}[${2:N}][${3:N}];
int coda_$1[$2][$3];

//init
for (int i = 0; i < $2; ++i)
{
	for (int j = 0; j < $3; ++j)
	{
		pthread_cond_init(&m.$1[i][j],NULL);
		m.coda_$1[i][j]=0;
	}
}

//print_status()
for (int i = 0; i < $2; ++i)
{
		for (int j = 0; j < $3; ++j)
		{
			printf("\t\tm.coda_$1[%d][%d]: %d\n",i,j,m.coda_$1[i][j]);
		}
}
endsnippet

snippet cnew3 "pthread cond[][][]" b
pthread_cond_t ${1:name}[${2:N}][${3:N}][${4:N}];
int coda_$1[$2][$3][$4];

//init
for (int i = 0; i < $2; ++i)
{
	for (int j = 0; j < $3; ++j)
	{
		for (int k = 0; k < $4; ++k)
		{
			pthread_cond_init(&m.$1[i][j][k],NULL);
			m.coda_$1[i][j][k]=0;
		}
	}
}

//print_status()
for (int i = 0; i < $2; ++i)
{
		for (int j = 0; j < $3; ++j)
		{
			for (int k = 0; k < $4; ++k)
			{
				printf("\t\tm.coda_$1[%d][%d][%d]: %d\n",i,j,k,m.coda_$1[i][j][k]);
			}
		}
}

endsnippet

snippet mval "monitor variable" b
int ${1:name};
$0
m.$1=0;
printf("m.$1: %d\n",m.$1); //print_status
endsnippet

snippet mon "new empty monitor" b
typedef struct monitor
{
	pthread_mutex_t mut;
	pthread_mutex_init(&m.mut,NULL);//init

}monitor;

monitor m;

endsnippet
snippet ty "typedef" b
typedef struct ${1:name}
{
	int id;
}$1;

$1 new_$1(int id)
{
	$1 s; //struttura
	s.id = id;

	return s;
}
endsnippet
snippet r "rand()" 
rand()%${1:n};
endsnippet

#------------------
snippet ioroutine "entra-esce routine (per monitor)" b
// copia in routine$0
in${2:sigla}($4);
sleep(rand()%5);
out$2($4);
//${1:routine_name} $2 entra
void in$2(${3:type} ${4:var_name})
{
	pthread_mutex_lock(&m.mut);
	while(false){ //condizione di wait
	
	}
	printf("$1 [%d] $2 entra \n",id);

	pthread_mutex_unlock(&m.mut);
}

//$1 $2 esce
void out$2($3 $4)
{
	pthread_mutex_lock(&m.mut);
	printf("$1 [%d] $2 esce\n",id);

	pthread_mutex_unlock(&m.mut);
}
endsnippet
snippet cw "cond_wait" b
pthread_cond_wait(&m.${1:cond},&m.mut);
endsnippet

snippet cs "cond_signal" b
pthread_cond_signal(&m.${1:cond});
endsnippet

snippet cb "cond_post" b
pthread_cond_broadcast(&m.${1:cond});
endsnippet

snippet tipo "diverso tipo" b
int ${1:tipo};
$1= rand()%${2:ntipi};
if ($1==0) //tipo 1
{
	$0
}
else if ($1==$2-1) { //ultimo tipo 

}
endsnippet

snippet srepcond "repeat while condition sem" b
while(1) {
	if (${1:cond uscita non verificata})
	{
		//do
		$0
	}
	else {
		//condizione di uscita verificata
		break;
	}
}

endsnippet

snippet ml "lock mutex" b
pthread_mutex_lock(&${1:m.}mut);
pthread_mutex_unlock(&$1mut);
endsnippet

snippet mul "unlock mutex" b
pthread_mutex_unlock(&${1:m.}mut);
endsnippet

snippet mnew "new mutex" b
pthread_mutex_t mut;
	pthread_mutex_init(&${1:m.}mut,NULL);
endsnippet

snippet slp "sleep random 5 sec" b
sleep(rand()%5);
endsnippet

snippet sval "semaphore variable" b
int ${1:name};
$0
$1=0;
printf("$1: %d\n",$1); //print_status;
endsnippet

snippet snew "new semaphore" b
static sem_t ${1:name};
	sem_init(&$1,0,0);

endsnippet
snippet sw "se sem 0 sospende th " 
sem_wait (&${1:sem});
$0
endsnippet

snippet sp "rispveglia th sospeso su sem"
sem_post (&${1:sem});
$0
endsnippet

snippet multip "create multiple thread" 
pthread_t ${1:th_name}[${2:MAXT}];
$0

//creazione $1
for (int i = 0; i < $2; ++i)
{
	if(pthread_create(&$1[i],NULL,${3:routine_name},(void *)${4:i})<0)
	{
		fprintf(stderr, "errore creazione thread $3 [%d]\n",i);
		exit(1);
	}
}

//wait $1
for (int i = 0; i < $2; ++i)
{
	if(pthread_join($1[i],NULL)){
		fprintf(stderr, "errore terminazione thread $3 [%d]\n",i);
		exit(1);
	}
	else {
		printf("thread $3 [%d] termiato con successo\n", i);
	}
}
endsnippet

snippet singp "create single thread" b
pthread_t ${1:th_name};
$0
//creazione $3
if(pthread_create(&$1,NULL,${3:routine_name},(void *)${4:0})<0)
{
	fprintf(stderr, "errore creazione thread $3\n");
	exit(1);
}

//wait $3
if(pthread_join($1,NULL)){
	fprintf(stderr, "errore terminazione thread $3 [%d]\n");
	exit(1);
}
else {
	printf("pthread $3 termiato con successo\n");
}
endsnippet

snippet sroutine "start process" b
void* ${1:routine}(void* arg)
{
	int id = (int)arg;
	printf("$1 [%d] creato\n",id);
	$0
	pthread_exit(NULL);
}
endsnippet

snippet mbar "message bar" b
printf("-----	${1:message}	------\n");
endsnippet

snippet divbar "division bar" b
printf("-----------------------------n");
endsnippet

#=======================================================================================

#snippet routine "start process" b
#void* ${1:routine}(void* arg)
#{
	#int id = (int)arg;
	#$0
	#startS${2:S}(&p,id,tipo);
	#sleep(1);
	#stop${2:S}(&p,id,tipo);
	#pthread_exit(NULL);
#}
#endsnippet

#snippet pjoin "pthread_join" 
#for (i = 0; i < ${1:NUM_THREAD}; ++i)
#{
	#if(pthread_join(${2:thread}[i],(void *)&${3:retval})){
		#fprintf(stderr, "thread [%d] terminato con error \n",i);
		#exit(1);
	#}
	#else {
		#printf("pthread [%d] termiato con successo\n", i);
	#}
#}
#$0
#endsnippet

#snippet pfun "void* func" 
#void* ${1:name}(void* arg)
#{
	#int id = (int)arg;
	#$0
#}
#endsnippet
#snippet plainmonitor "monitor" 
#typedef struct
#{
	#int ${1:val};
	#pthread_cond_t ${2:coda}[${3:N}]; 
	#int ${4:ncoda}[${3:N}]; 
	#pthread_mutex_t mut;
#} monitor;

#monitor m; 

#void init(monitor* m)
#{
	#int i;
	#printf("----- inizializzazione monitor ------\n");
	#m->$1=0;
	#printf("m->$1: %d\n", m->$1);	
	#$0

	#for (i = 0; i < $3; ++i)
	#{
		#pthread_cond_init(&m->$2[i],NULL);
		#m->$4[i]=0;
		#printf("$4[ %d ][ %d ][ %d ]: %d \n",i,m->$4[i]);
	#}
	#pthread_mutex_init(&m->mut,NULL);
	#printf("---------------------------------------\n");
#}
#endsnippet

#snippet critic "start stop critic" b
#void start${1:S}(monitor* m,${2:arg})
#{
	#pthread_mutex_lock(&m->mut);
	#//zona critica
	#$0

	#pthread_mutex_unlock(&m->mut);
#}

#void stop${1:S}(monitor* m,${2:arg})
#{
	#pthread_mutex_lock(&m->mut);
	#//zona critica

	#pthread_mutex_unlock(&m->mut);
#}
#endsnippet

#snippet monitor "monitor" 
#typedef struct
#{
	#int ${1:val}
	#pthread_cond_t ${2:coda}[${3:N}]; 
	#int ${4:ncoda}[${3:N}]; 
	#pthread_mutex_t mut;
#} ${5:monitor};

#$5 ${6:monitor_name};

#void init($5* $6)
#{
	#int i;
	#printf("----- inizializzazione monitor $5------\n");
	#$6->$1=0;
	#printf("$6->$1: %d\n", $6->$1);	

	#for (i = 0; i < $3; ++i)
	#{
		#pthread_cond_init(&$6->$2[i],NULL);
		#$6->$4[i]=0;
		#printf("$4[ %d ][ %d ][ %d ]: %d \n",i,m->$4[i]);
	#}
	#pthread_mutex_init(&m->mut,NULL);
	#printf("---------------------------------------\n");
#}
#endsnippet


#snippet mounfun "monitor function" 

#void ${1:name}(${2:void* arg})
#{
	#int id = (int)arg;

	#pthread_mutex_lock(&m->mut);
	#$0
	#pthread_mutex_unlock(&m->mut);
#}
#endsnippet


#snippet void "(void *)" 
#(void *)
#endsnippet



#=============== old stuff ==========

#snippet mal "malloc" 
#(${1:type}*)malloc(${2:mult} * sizeof($1));
#$0
#endsnippet

#snippet d "[%d]" 
#[%${1:d}]$0
#endsnippet

#snippet chknarg "check number of argument" 
#//Check number of arguments
#if(argc <= ${1:number}){
	#printf("Illegal number of parameters\n");
	#exit(1);
#}
#${0}
#endsnippet

#snippet chkdig "check argument isdigit" 

#//Check argument is digit
#if(!isdigit(argv[${1:number}][0])){
	#printf("%d parameter is not digit\n",argv[$1]);
	#exit(1);
#}
#${0}
#endsnippet

#snippet mess "string for debugging" 
#printf("th[%d]-${1:message}\n",id${2});
#${0}
#endsnippet

#snippet vector "vector creation" 
#int i;
#int* vector;
#vector = (int *)malloc(${1:mult}*sizeof(int));
#for(i = 0; i < $1; ++i)
#{
	#vector[i] = rand() % range + 1;
#}
#printf("vector:\n");
#for (i = 0; i < $1; ++i)
#{
	#if (i%10==0 && i!=0)
	#{
		#printf("\n");
	#}
	#printf("[%d]\t",vector[i]);
#}
#printf("\n");
#endsnippet

#snippet oldskltn "proj skeleton" 
##include <stdio.h>
##include <stdlib.h>
##include <string.h>

#void wait_child();

#int main(int argc, char *argv[])
#{
	#int i;
	#int n_children;
	#int father_pid;
	#int pid[MAX];

	#// Print all argument (debug purpose)
	#printf("Arguments:\n");
	#for (i = 0; i < argc; i++)
		#printf("[%d]:%s\n", i,argv[i]);

	#//Check number of arguments
	#if(argc < ${1:N+1}){
		#printf("Illegal number of parameters\n");
		#exit(1);
	#}
	
	#//Check argument is digit
	#if(!isdigit(argv[${2:num}][0])){
		#printf("%d parameter is not digit\n",argv[$2][0]);
		#exit(1);
	#}

	#//Check argument is positive
	#if (argv[1][0] <= 0)
	#{
		#printf("%d must be >0\n",argv[$2][0]);
		#exit(1);
	#}
	
	#${3:if par num children -> n_children}= atoi(argv[$2]);
	#${4:n_children =}
	#printf("n_children = %d\n", n_children);
	#printf("----- start program -----\n");
	#father_pid = getpid();
	
	#for (i = 0; i < n_children; ++i)
	#{
		#//printf("about to create child [%d]\n", i);
		#pid[i] = fork();
		#if (pid[i] == 0)	//child
		#{
			#printf("child:pid - [%d][%d]\n",i,getpid());
			#${0:child_code}
		#}
		#else if (pid[i] > 0)//father
		#{}
		#else //Errors
		#{
			#perror("Unable to fork()");
			#exit(2);
		#}
	#}

	#//father code
	#for (i = 0; i < n_children; ++i)
	#{
		#wait_child();
	#}
	#return 0;
#}

#void wait_child() {
	#int status,pid;
	#pid = wait(&status);
	#if ( WIFEXITED(status) ) {
		#printf("Figlio %d terminato volontariamente con stato di terminazione %d\n",pid, WEXITSTATUS(status));
	#}
	#else if ( pid < 0)                                                                      
	#{                                                                                       
		#perror("Impossibile completare la wait");                                     
	#}     
	#else if ( WIFSIGNALED(status) )
	#{
		#printf("Figlio %d terminato dal segnale num. %d\n",pid, WTERMSIG(status));
	#}
#}
#endsnippet

