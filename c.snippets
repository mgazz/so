
snippet wow
int ${1:name}

`!p snip.rv=t[1]`=0;


endsnippet


#==================================================
snippet sem_wait "se valore sem 0 sospende th chiamante" 
sem_wait (&${1:my_sem});
$0
endsnippet


snippet sem_post "se almeno 1 th sospeso nella coda del sem viene risvegliato, se no sem incr"
sem_post (&${1:my_sem});
$0
endsnippet

snippet pcreate "pthread_create" 
for (i = 0; i < ${1:NUM_THREAD}; ++i)
{
	if(pthread_create(&${3:thread},NULL,${2:routine},${3:(void *)i})<0)
	{
		fprintf(stderr, "pthread_create error for thread 1\n");
		exit(1);
	}
}
$0
endsnippet

snippet pjoin "pthread_join" 
for (i = 0; i < ${1:NUM_THREAD}; ++i)
{
	if(pthread_join(${2:thread}[i],(void *)&${3:retval})){
		fprintf(stderr, "thread [%d] terminato con error \n",i);
		exit(1);
	}
	else {
		printf("pthread [%d] termiato con successo\n", i);
	}
}
$0
endsnippet

snippet pimport "import for pthread" 
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
endsnippet
snippet pfun "void* func" 
void ${1:name}(void* arg)
{
	int id = (int)arg;
	$0
}
endsnippet

snippet mounfun "monitor function" 

void ${1:name}(${2:void* arg})
{
	int id = (int)arg;

	pthread_mutex_lock(&m->mut);
	$0
	pthread_mutex_unlock(&m->mut);
}
endsnippet


snippet void "(void *)" 
(void *)
endsnippet

snippet montemp "monitor template" 

typedef struct ${1:monitor}
{
	int ;
	pthread_mutex_t mut;
	pthread_cond_t coda[2];
	int ncoda[2];
}

$1 ${2:monitor_name};

void init($1 * m)
{
	int i;
	printf("----- inizializzazione monitor------\n");
	pthread_mutex_init(&m->mut,NULL);

	m->u1=0;
	printf("u2=\n"m->u2);

	for (i = 0; i < 2; ++i)
	{
		//inizializzo le condizioni e le code
		pthread_cond_init(&m->coda[i]);
		m->coda[i]=0;
	}

	printf("------------------------\n");
}


int main()
{
	int i;
	pthread_t th[N];
	
	printf("---- start ----");
	
	srand(time(NULL));
	init(&mn);
	
	sleep(2);
	
	for(i = 0; i < N; i++)
	{
		pthread_create(&th[i], NULL, routine, (void*)i);
		pthread_create(&portatori[i], NULL, portatore, (void*)I1);
		
	}

	//aspetto terminazione
	for(i = 0; i < N; i++)
	{
		if(pthread_join(th[i],NULL)){
			fprintf(stderr, "thread [%d] terminato con error \n",i);
			exit(1);
		}
		else {
			printf("pthread [%d] termiato con successo\n", i);
		}
	}
	return 0;
}
endsnippet



#=============== old stuff ==========

snippet mal "malloc" 
(${1:type}*)malloc(${2:mult} * sizeof($1));
$0
endsnippet

snippet d "[%d]" 
[%${1:d}]$0
endsnippet

snippet chknarg "check number of argument" 
//Check number of arguments
if(argc <= ${1:number}){
	printf("Illegal number of parameters\n");
	exit(1);
}
${0}
endsnippet

snippet chkdig "check argument isdigit" 

//Check argument is digit
if(!isdigit(argv[${1:number}][0])){
	printf("%d parameter is not digit\n",argv[$1]);
	exit(1);
}
${0}
endsnippet

snippet mess "string for debugging" 
printf("th[%d]-${1:message}\n",id${2});
${0}
endsnippet

snippet vector "vector creation" 
int i;
int* vector;
vector = (int *)malloc(${1:mult}*sizeof(int));
for(i = 0; i < $1; ++i)
{
	vector[i] = rand() % range + 1;
}
printf("vector:\n");
for (i = 0; i < $1; ++i)
{
	if (i%10==0 && i!=0)
	{
		printf("\n");
	}
	printf("[%d]\t",vector[i]);
}
printf("\n");
endsnippet

